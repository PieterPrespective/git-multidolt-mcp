# PP13-74: Implement Carry Mode for Branch Switching with Uncommitted Changes

- IssueID = PP13-74
- Please read 'Prompts/BasePrompt.md' first for general context
- This assignment implements the **carry mode** feature for branch switching, enabling users to preserve uncommitted ChromaDB changes when switching between Dolt branches. The current implementation logs "Carrying X uncommitted changes" but then removes those changes during the branch sync process.

## Background Context

For context please read:
- The PP13-69 architecture overview in 'Prompts/pp13-69.md' - foundational SQLite sync state architecture
- The PP13-69-C1 through PP13-69-C4 development logs in the chroma design planning database
- Test file: `multidolt-mcp-testing/IntegrationTests/BranchSwitchingIntegrationTests.cs` - specifically `TestUncommittedChangesHandling()` starting at line 838

## Problem Statement

The `if_uncommitted=carry` option in `DoltCheckoutTool` is intended to preserve uncommitted local changes when switching branches. Currently, the feature is partially implemented:

1. **What Works**: The checkout tool correctly detects uncommitted changes and sets `preserveLocalChanges=true`
2. **What Fails**: The `SyncChromaToMatchBranch` method ignores this flag and removes all documents not present in Dolt on the target branch

### Evidence from Test Log

From `Examples/260113_FailedTests/TestUncommittedChangesHandling-*.testlog`:

```
[DoltCheckoutTool] Carrying 1 uncommitted changes to new branch 'test-feature'
[DoltCheckoutTool] Change details: 1 new, 0 modified, 0 deleted
[DoltCheckoutTool] Initiating checkout to 'test-feature' (create=False, carry_mode=True)
...
PP13-69-C7 TRACE: ProcessCheckoutAsync called with target=test-feature, createNew=False, preserveChanges=True
...
PP13-69-C7 EXACT SYNC: ChromaDB has 3 documents: [initial-1, uncom-main-1, carry-1]
Removing 2 stale documents from collection 'test-collection': [uncom-main-1, carry-1]  <-- PROBLEM!
Deleted 2 documents/chunks from collection 'test-collection'
```

The document `carry-1` was the uncommitted change that should have been preserved, but it was deleted during the sync.

## Technical Analysis

### Current Code Flow

1. **DoltCheckoutTool.cs (line 194)**:
   ```csharp
   bool preserveLocalChanges = if_uncommitted == "carry";
   ```
   Correctly sets the flag based on user's choice.

2. **SyncManagerV2.ProcessCheckoutAsync (line 612-665)**:
   ```csharp
   public async Task<SyncResultV2> ProcessCheckoutAsync(
       string targetBranch,
       bool createNew = false,
       bool preserveLocalChanges = false)  // Flag received but not used!
   {
       // ... checkout logic ...

       // Line 646: This call ignores preserveLocalChanges!
       await SyncChromaToMatchBranch(targetBranch);

       // ... rest of checkout ...
   }
   ```

3. **SyncChromaToMatchBranch**: This method synchronizes ChromaDB to exactly match Dolt's state on the target branch, removing any documents that don't exist in Dolt - including the uncommitted changes the user wanted to carry.

### Root Cause

The `preserveLocalChanges` parameter is passed to `ProcessCheckoutAsync` but is:
1. Never passed to `SyncChromaToMatchBranch`
2. `SyncChromaToMatchBranch` doesn't have logic to preserve documents with `is_local_change=true` metadata

## Implementation Requirements

### Primary Goals

1. **Preserve Local Changes During Carry Mode**: When `preserveLocalChanges=true`, documents with `is_local_change=true` metadata must be retained in ChromaDB after branch switch
2. **Maintain Data Consistency**: Carried changes should be correctly tracked as uncommitted on the new branch
3. **Handle Collection-Level Changes**: New collections created locally must also be preserved in carry mode
4. **Update Change Detection**: After carry, `GetLocalChangesAsync()` must correctly identify carried changes as local changes

### Architectural Design Considerations

There are multiple approaches to implementing carry mode. Consider the trade-offs:

#### Option A: Pre-Checkout Snapshot Approach
- Before checkout: Capture all documents with `is_local_change=true`
- Perform checkout and sync normally
- After sync: Re-add the captured documents with their metadata preserved

**Pros**: Minimal changes to existing sync logic
**Cons**: Additional I/O overhead, potential race conditions

#### Option B: Sync-Aware Preservation
- Modify `SyncChromaToMatchBranch` to accept `preserveLocalChanges` parameter
- When removing "stale" documents, skip those with `is_local_change=true`
- Handle collection removal similarly

**Pros**: More efficient, single-pass operation
**Cons**: More invasive changes to sync logic

#### Option C: Deferred Sync Approach
- In carry mode, skip `SyncChromaToMatchBranch` entirely
- Only sync documents that conflict between branches
- Maintain full local state preservation

**Pros**: Maximum preservation, simpler logic
**Cons**: May leave ChromaDB in inconsistent state with mixed branch data

### Recommended Approach: Option B (Sync-Aware Preservation)

This approach provides the best balance of data integrity and implementation complexity.

### Implementation Steps

#### Step 1: Modify SyncChromaToMatchBranch Signature

```csharp
// Before
private async Task SyncChromaToMatchBranch(string targetBranch)

// After
private async Task SyncChromaToMatchBranch(string targetBranch, bool preserveLocalChanges = false)
```

#### Step 2: Pass Flag Through ProcessCheckoutAsync

Update line ~646 in `SyncManagerV2.cs`:
```csharp
// Before
await SyncChromaToMatchBranch(targetBranch);

// After
await SyncChromaToMatchBranch(targetBranch, preserveLocalChanges);
```

#### Step 3: Preserve Documents in Differential Sync

In `SyncChromaToMatchBranch`, when identifying documents to remove:

```csharp
// When removing stale documents from a collection
var documentsToRemove = chromaDocIds.Except(doltDocIds).ToList();

if (preserveLocalChanges)
{
    // Get metadata for documents being considered for removal
    var docsToCheck = await _chromaService.GetDocumentsAsync(collectionName, documentsToRemove);

    // Filter out documents with is_local_change=true
    var protectedDocs = new HashSet<string>();
    if (docsToCheck is Dictionary<string, object> results)
    {
        var ids = results["ids"] as List<object>;
        var metadatas = results["metadatas"] as List<object>;

        for (int i = 0; i < ids.Count; i++)
        {
            var metadata = metadatas[i] as Dictionary<string, object>;
            if (metadata?.TryGetValue("is_local_change", out var isLocal) == true)
            {
                if (isLocal is bool b && b)
                    protectedDocs.Add(ids[i].ToString());
                else if (isLocal?.ToString().Equals("true", StringComparison.OrdinalIgnoreCase) == true)
                    protectedDocs.Add(ids[i].ToString());
            }
        }
    }

    documentsToRemove = documentsToRemove.Except(protectedDocs).ToList();

    if (protectedDocs.Count > 0)
    {
        _logger.LogInformation("PP13-74 CARRY MODE: Preserved {Count} local changes: [{Docs}]",
            protectedDocs.Count, string.Join(", ", protectedDocs));
    }
}
```

#### Step 4: Preserve Collections in Carry Mode

In Phase 1 of `SyncChromaToMatchBranch`, when removing stale collections:

```csharp
if (preserveLocalChanges)
{
    // Check if collection contains any local changes before removing
    foreach (var collectionToRemove in collectionsToRemove.ToList())
    {
        var docs = await _chromaService.GetDocumentsAsync(collectionToRemove);
        // Check if any document has is_local_change=true
        // If so, remove from collectionsToRemove list
    }
}
```

#### Step 5: Update GetLocalChangesAsync Behavior

Ensure that after a carry-mode checkout, the carried documents are still correctly identified as local changes. The `is_local_change` metadata should remain intact.

#### Step 6: Add Logging for Carry Mode Operations

Add comprehensive logging to trace carry mode behavior:
```csharp
_logger.LogInformation("PP13-74 CARRY MODE ACTIVE: Preserving uncommitted local changes during checkout to {Branch}", targetBranch);
```

### Edge Cases to Handle

1. **Document Conflicts**: What if the target branch has a document with the same ID but different content?
   - Recommendation: Preserve the local version (it's uncommitted work), log a warning

2. **Chunked Documents**: If a document was chunked (`doc-1_chunk_0`, `doc-1_chunk_1`), ensure all chunks are preserved together

3. **Metadata Preservation**: Ensure all metadata including `content_hash`, `is_local_change`, `last_updated` survives the carry operation

4. **Nested Carries**: User carries changes from main to feature-A, then from feature-A to feature-B
   - The changes should still be tracked as local and uncommitted

5. **Deleted Documents**: If user deleted a document locally (tracked in deletion database), this deletion should also be carried

## Success Criteria

```
Test: TestUncommittedChangesHandling
Expected Result: PASS

Specific Assertions:
1. After carry-mode checkout, localChanges.HasChanges == true
2. After carry-mode checkout, localChanges.TotalChanges > 0
3. Carried documents are queryable in ChromaDB on new branch
4. Carried documents retain is_local_change=true metadata
5. Subsequent commit on new branch includes carried changes
```

### Full Test Suite Validation

Run all branch switching tests to ensure no regressions:
```
dotnet test --filter "FullyQualifiedName~BranchSwitching"
dotnet test --filter "FullyQualifiedName~PP13_69"
```

All tests should pass including:
- `TestUncommittedChangesHandling` (the failing test this fixes)
- `TestBranchSwitchingWithNoChanges`
- `TestCommitFirstMode`
- `TestResetFirstMode`
- All PP13-69 Phase tests

## Files to Modify

### Primary Files

1. **`multidolt-mcp/Services/SyncManagerV2.cs`**
   - `ProcessCheckoutAsync`: Pass `preserveLocalChanges` to sync method
   - `SyncChromaToMatchBranch`: Add logic to preserve local changes
   - Add helper method for checking `is_local_change` metadata

2. **`multidolt-mcp/Tools/DoltCheckoutTool.cs`**
   - Add enhanced logging for carry mode operations
   - Potentially add post-checkout validation for carried changes

### Secondary Files (if needed)

3. **`multidolt-mcp/Services/ChromaPythonService.cs`**
   - May need helper method to efficiently check metadata for multiple documents

4. **`multidolt-mcp/Services/ISyncManagerV2.cs`**
   - Update interface if method signatures change

### Test Files

5. **`multidolt-mcp-testing/IntegrationTests/BranchSwitchingIntegrationTests.cs`**
   - `TestUncommittedChangesHandling`: Should pass after implementation
   - Consider adding additional carry mode edge case tests

## Technical Constraints

- **DO NOT** break existing sync functionality for non-carry-mode checkouts
- **MAINTAIN** PP13-69 architectural promises (SQLite sync state isolation)
- **PRESERVE** all existing passing tests
- **ENSURE** proper logging for troubleshooting carry mode issues
- **AVOID** introducing race conditions or data corruption scenarios

## Validation Process

1. **Unit Testing**: Add unit tests for metadata-aware document filtering
2. **Integration Testing**: Run `TestUncommittedChangesHandling` to verify fix
3. **Regression Testing**: Run full PP13-69 and BranchSwitching test suites
4. **Edge Case Testing**: Manually test chunked documents, collection preservation, nested carries
5. **Performance Validation**: Ensure carry mode doesn't significantly impact checkout performance

## Expected Outcome

After implementation:
1. `if_uncommitted=carry` correctly preserves uncommitted ChromaDB changes during branch switch
2. Carried changes are correctly identified as local changes on the new branch
3. Users can continue working on their uncommitted changes on the new branch
4. Subsequent commits include the carried changes
5. All existing tests continue to pass

## Priority

**Medium-High** - This is a user-facing feature that enables flexible workflow patterns. Not blocking other features but improves usability significantly.

## Estimated Complexity

**Medium** - Requires careful modification of sync logic without breaking existing functionality. Key challenge is correctly identifying and preserving local changes during the differential sync process.

---

Please log all development actions to the 'chroma-feat-design-planning-mcp' database under collection 'PP13-74' following the established pattern.
