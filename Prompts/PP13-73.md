- IssueID = PP13-73
- Please read 'Prompts/BasePrompt.md' first for general context
- The merge execution functionality has critical bugs preventing correct conflict resolution. The `keep_theirs` resolution silently fails due to column name mismatches, and auxiliary table conflicts block merges even when only document conflicts are relevant to the user.
- For context please read:
	- The issue report 'Examples/260111_MergeExecutionIssueRecurrence.md' - detailed reproduction of the issues
	- The earlier issue report 'Examples/260109_MergeExecutionTestIssue.md' - initial discovery of merge resolution problems
	- The PP13-72-C4 investigation logged in the chroma design planning database - complete root cause analysis
	- The current implementation in 'multidolt-mcp/Services/DoltCli.cs' (lines 933-1035) - ResolveDocumentConflictAsync
	- The current implementation in 'multidolt-mcp/Tools/ExecuteDoltMergeTool.cs' - merge execution flow

## **Executive Summary**

Two critical bugs in merge execution are causing data integrity issues:

1. **Issue 1**: Auxiliary table conflicts (`chroma_sync_state`, `document_sync_log`) block merge commits even when users only care about `documents` table conflicts
2. **Issue 2**: The `keep_theirs` conflict resolution silently fails due to SQL column name mismatches, leaving documents with incorrect content while reporting success

---

## **Issue 1: Auxiliary Table Conflicts Block Merge**

### **Problem Description**
When executing a merge, the commit fails with:
```
"tables [chroma_sync_state document_sync_log documents] have unresolved conflicts from the merge"
```

The conflict detection and resolution only checks the `documents` table, leaving auxiliary tables unresolved.

### **Root Cause**
- `ExecuteDoltMergeTool.cs:175`: `GetDetailedConflictsAsync("documents")` - only queries documents
- `SyncManagerV2.cs:895`: `GetConflictsAsync("documents")` - same limitation
- Auxiliary tables are never checked or resolved

### **Affected Tables**

| Table | Purpose | Auto-Resolve Strategy |
|-------|---------|----------------------|
| `chroma_sync_state` | Sync tracking per collection | `--ours` (can regenerate) |
| `document_sync_log` | Sync operation history | `--ours` (can regenerate) |
| `local_changes` | Temporary change tracking | `--ours` (can discard) |
| `collections` | Collection metadata | **Manual** (see edge cases below) |
| `documents` | User document content | **Manual** (user must decide) |

### **Required Fix**
Before processing document conflicts, auto-resolve auxiliary table conflicts:
```csharp
// After dolt merge detects conflicts, auto-resolve non-document tables
var auxiliaryTables = new[] { "chroma_sync_state", "document_sync_log", "local_changes" };
foreach (var table in auxiliaryTables)
{
    if (await HasConflictsInTableAsync(table))
    {
        await _doltCli.ResolveAllConflictsAsync(table, "--ours");
    }
}
// Then proceed with document/collection conflict handling
```

### **Edge Case: Collections Table Conflicts**

**CRITICAL**: The `collections` table requires special handling due to foreign key relationships:

```sql
-- documents.collection_name references collections.collection_name ON DELETE CASCADE
```

**Dangerous Scenarios:**

1. **Collection deleted in source branch, documents added in target branch**:
   - If auto-resolved with `--theirs`: Collection deleted, CASCADE deletes target's new documents
   - **Data loss risk!**

2. **Collection renamed in source, documents reference old name in target**:
   - FK violation possible
   - Orphaned documents in Dolt

**Recommended Handling for `collections` table**:
- Option A: Include in manual conflict resolution (like `documents`)
- Option B: Always resolve with `--ours` to preserve current branch's collections
- Option C: Detect deletion conflicts specifically and warn user

**Test Required**: Create scenario where Branch A deletes a collection that Branch B adds documents to.

---

## **Issue 2: keep_theirs Resolution Silently Fails**

### **Problem Description**
When resolving conflicts with `keep_theirs`:
- Resolution reports success
- Conflict row is deleted
- Document content is NOT updated (still has "ours" content)

### **Root Cause Analysis**

#### **Bug #1: Wrong Column Names (DoltCli.cs:995-999)**

```csharp
var updateDocSql = $@"
    UPDATE {tableName}
    SET content = (SELECT their_content FROM {conflictTableName} WHERE our_doc_id = '{escapedDocId}'),
        doc_metadata = (SELECT their_doc_metadata FROM {conflictTableName} WHERE our_doc_id = '{escapedDocId}')
    WHERE doc_id = '{escapedDocId}'";
```

| Code Uses | Actual Column | Table |
|-----------|---------------|-------|
| `doc_metadata` | `metadata` | documents |
| `their_doc_metadata` | `their_metadata` | dolt_conflicts_documents |

**Result**: UPDATE fails with "Unknown column 'doc_metadata'" error.

#### **Bug #2: Dynamic Column Discovery Ignored (DoltCli.cs:982-1004)**

The code correctly queries conflict table columns:
```csharp
var setClauses = theirColumns
    .Select(theirCol => {
        var ourCol = theirCol.Replace("their_", "our_");
        return $"{ourCol} = {theirCol}";  // Correct!
    })
    .ToList();
```

But then **ignores the result** and uses hardcoded wrong SQL!

#### **Bug #3: Fallback Only Updates Content (DoltCli.cs:1011-1017)**

When primary UPDATE fails, fallback only updates `content`:
```csharp
var simpleUpdateSql = $@"
    UPDATE {tableName}
    SET content = (SELECT their_content FROM {conflictTableName} WHERE our_doc_id = '{escapedDocId}')
    WHERE doc_id = '{escapedDocId}'";
```

**Missing columns**:
- `metadata` - not copied from `their_metadata`
- `content_hash` - not recalculated
- `title`, `doc_type` - not copied
- `updated_at` - not updated

#### **Bug #4: Missing collection_name in WHERE Clause**

Documents table has composite PK `(doc_id, collection_name)`:
```sql
WHERE doc_id = 'someid2'  -- Missing: AND collection_name = 'main'
```

Subquery also missing filter:
```sql
SELECT their_content FROM dolt_conflicts_documents WHERE our_doc_id = 'someid2'
-- Missing: AND our_collection_name = 'main'
```

#### **Bug #5: No Result Verification (DoltCli.cs:1020-1026)**

```csharp
// Delete the conflict row after updating the document
var deleteSql = $"DELETE FROM {conflictTableName} WHERE our_doc_id = '{escapedDocId}'";
await ExecuteAsync(deleteSql);
return new DoltCommandResult(true, ...);  // Always reports success!
```

Even if UPDATE affected 0 rows, the code:
1. Reports success
2. Deletes conflict row
3. Leaves document with wrong content

---

## **Assignment Objectives**

### **Primary Goals:**

1. **Fix Auxiliary Table Auto-Resolution**: Implement automatic resolution of non-user-data table conflicts before document conflict handling
2. **Fix keep_theirs Resolution**: Correct the SQL column names and ensure resolution actually updates documents
3. **Handle collections Table Edge Cases**: Implement safe handling for collection deletion/modification conflicts
4. **Add Comprehensive Test Coverage**: Verify mixed resolutions and edge cases

### **Success Criteria:**

```
- Merge execution succeeds when auxiliary tables have conflicts
- keep_theirs resolution correctly updates document content
- keep_ours resolution continues to work correctly
- Mixed resolutions (some ours, some theirs) produce correct results
- Collection deletion edge cases are handled safely
- All existing merge tests continue to pass
- New tests verify all fix scenarios
```

---

## **Implementation Requirements**

### **Phase 1: Fix ResolveDocumentConflictAsync (Critical)**

**Location**: `DoltCli.cs:933-1035`

1. **Fix Column Names**:
   - Change `doc_metadata` → `metadata`
   - Change `their_doc_metadata` → `their_metadata`

2. **Use Dynamic Column Discovery**:
   - Actually use the `setClauses` variable that's already built
   - Build UPDATE from discovered columns, not hardcoded

3. **Add collection_name Filter**:
   - Add `collection_name` parameter to method signature
   - Include in both WHERE clause and subquery

4. **Verify UPDATE Success**:
   - Check rows affected by UPDATE
   - Only delete conflict row if UPDATE succeeded
   - Return failure if UPDATE affected 0 rows

5. **Update All Relevant Columns**:
   - Copy all `their_*` columns to main table, not just content
   - Recalculate `content_hash` if needed
   - Update `updated_at` timestamp

### **Phase 2: Implement Auxiliary Table Auto-Resolution**

**Location**: `ExecuteDoltMergeTool.cs` and/or `MergeConflictResolver.cs`

1. **Add Method to Check Table Conflicts**:
   ```csharp
   Task<bool> HasConflictsInTableAsync(string tableName)
   ```

2. **Auto-Resolve Before Document Handling**:
   ```csharp
   var auxiliaryTables = new[] { "chroma_sync_state", "document_sync_log", "local_changes" };
   foreach (var table in auxiliaryTables)
   {
       if (await HasConflictsInTableAsync(table))
       {
           await _doltCli.ResolveAllConflictsAsync(table, "--ours");
           _logger.LogInformation("Auto-resolved conflicts in auxiliary table {Table} with --ours", table);
       }
   }
   ```

3. **Handle collections Table Specially**:
   - Detect if collections table has conflicts
   - Check if conflict involves deletion (base exists, their doesn't)
   - If deletion conflict: Include in manual resolution OR resolve with --ours and warn
   - If metadata-only conflict: Can auto-resolve with --ours

### **Phase 3: Update MergeConflictResolver**

**Location**: `MergeConflictResolver.cs:265-297`

1. **Pass collection_name to Resolution**:
   - Update `DetailedConflictInfo` to include collection_name if not present
   - Pass to `ResolveDocumentConflictAsync`

2. **Verify Resolution Applied**:
   - Check return value from `ResolveDocumentConflictAsync`
   - Re-query document to verify content changed
   - Return accurate success/failure

### **Phase 4: Add Comprehensive Tests**

**Location**: `MergePreviewIntegrationTests.cs` or new test file

1. **Test: Mixed Resolutions with Content Verification**
   ```csharp
   [Test]
   public async Task MergeExecution_MixedResolutions_AppliesCorrectContent()
   {
       // Create 2 conflicts
       // Resolve doc1 with keep_ours, doc2 with keep_theirs
       // Verify doc1 has branch1 content, doc2 has branch2 content
   }
   ```

2. **Test: Auxiliary Table Auto-Resolution**
   ```csharp
   [Test]
   public async Task MergeExecution_AuxiliaryTableConflicts_AutoResolvedWithOurs()
   {
       // Create scenario with chroma_sync_state conflicts
       // Execute merge
       // Verify merge succeeds without manual aux table resolution
   }
   ```

3. **Test: Collection Deletion Edge Case**
   ```csharp
   [Test]
   public async Task MergeExecution_CollectionDeletedInSource_DocumentsPreserved()
   {
       // Branch A: Delete collection "test"
       // Branch B: Add documents to collection "test"
       // Merge A → B with --ours for collections
       // Verify collection and documents survive
   }
   ```

4. **Test: Custom Resolution with User Content**
   ```csharp
   [Test]
   public async Task MergeExecution_CustomResolution_AppliesUserProvidedContent()
   {
       // Create conflict
       // Resolve with custom content
       // Verify document has custom content
   }
   ```

---

## **Technical Constraints**

- **DO NOT** break existing merge preview functionality
- **MAINTAIN** compatibility with simple resolution scenarios
- **PRESERVE** the conflict ID generation logic (used to match previewed conflicts)
- **ENSURE** ChromaDB sync remains coherent after merge resolution
- **CONSIDER** that collection_name may be needed in conflict IDs for uniqueness

---

## **Validation Process**

1. Run existing merge tests to establish baseline
2. Implement Phase 1 fixes (ResolveDocumentConflictAsync)
3. Run tests - verify keep_theirs now works
4. Implement Phase 2 (auxiliary table auto-resolution)
5. Run tests - verify merge completes with aux table conflicts
6. Implement Phase 3 (MergeConflictResolver updates)
7. Run full test suite
8. Implement Phase 4 tests
9. Run complete validation

---

## **Expected Outcome**

After implementation:
- Merge execution correctly applies both `keep_ours` and `keep_theirs` resolutions
- Auxiliary table conflicts are automatically resolved without user intervention
- Collection deletion edge cases are handled safely
- Document content matches specified resolution
- All merge operations complete successfully when resolutions are provided
- Comprehensive test coverage validates all scenarios

---

## **Files to be Modified**

| File | Changes |
|------|---------|
| `multidolt-mcp/Services/DoltCli.cs` | Fix ResolveDocumentConflictAsync column names, add collection_name parameter, verify UPDATE success |
| `multidolt-mcp/Services/IDoltCli.cs` | Update interface for modified method signature |
| `multidolt-mcp/Services/MergeConflictResolver.cs` | Pass collection_name, verify resolution applied |
| `multidolt-mcp/Tools/ExecuteDoltMergeTool.cs` | Add auxiliary table auto-resolution before document handling |
| `multidolt-mcp-testing/IntegrationTests/MergePreviewIntegrationTests.cs` | Add comprehensive resolution tests |

---

## **Priority**: **Critical**

These bugs cause:
- Silent data corruption (wrong document content after merge)
- Failed merges requiring workarounds
- User trust issues with conflict resolution

Please log all development actions to the 'chroma-feat-design-planning-mcp' database under collection 'PP13-73' following the established pattern.
