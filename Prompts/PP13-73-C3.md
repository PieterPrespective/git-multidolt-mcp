# PP13-73-C3: Batch Conflict Resolution - Fix Per-Conflict Transaction Pattern

- IssueID = PP13-73-C3
- Please read 'Prompts/BasePrompt.md' first for general context
- The merge conflict resolution functionality is fundamentally broken due to a per-conflict transaction pattern that violates Dolt's merge constraints. Despite PP13-73-C1 (conflict ID consistency) and PP13-73-C2 (transaction wrapper) fixes, users cannot successfully execute merges with multiple conflicts.

## Context and Background

- For context please read:
  - The parent issue in 'Prompts/PP13-73.md' - the foundational merge execution issue
  - The PP13-73-C1 achievements in Chroma collection 'PP13-73-C1' - conflict ID consistency fix
  - The PP13-73-C2 achievements in Chroma collection 'PP13-73-C2' - transaction wrapper implementation
  - The detailed issue report in 'Examples/260112_MergeExecutionIssue3/260112_MergeFail3.md'
  - The full execution log in 'Examples/260112_MergeExecutionIssue3/vm-rag.log' (lines 350-500)

---

## Problem Summary

**User-facing symptom:** When executing a merge with multiple conflicts and providing valid conflict resolutions, the merge fails with:
```json
{
  "success": false,
  "error": "MERGE_COMMIT_FAILED",
  "message": "Failed to commit merge: tables [documents] have unresolved conflicts from the merge. resolve the conflicts before committing. Merge has been aborted."
}
```

**Root cause:** The implementation attempts to resolve conflicts one-at-a-time, with each resolution wrapped in its own transaction that tries to COMMIT. Dolt rejects these COMMITs because other conflicts still exist.

---

## Root Cause Analysis

### The Critical Dolt Constraint

Dolt enforces a strict rule: **You cannot COMMIT while ANY conflict rows remain in ANY `dolt_conflicts_*` table.**

Error from Dolt (log line 395):
```
error on line 3 for query COMMIT: Merge conflict detected, transaction rolled back.
Merge conflicts must be resolved using the dolt_conflicts and dolt_schema_conflicts
tables before committing a transaction. To commit transactions with merge conflicts,
set @@dolt_allow_commit_conflicts = 1
```

### Current Broken Flow

```
ExecuteDoltMergeTool.cs (lines 252-277)
  └─> foreach (conflict in conflicts)           // Process one at a time
        └─> MergeConflictResolver.ResolveConflictAsync()
              └─> DoltCli.ResolveDocumentConflictAsync()
                    └─> ExecuteInTransactionAsync([sql])
                          └─> SET @@autocommit = 0;
                          └─> DELETE FROM dolt_conflicts_documents WHERE ...;  // One conflict
                          └─> COMMIT;      ← FAILS! Other conflicts still exist!
                          └─> SET @@autocommit = 1;
```

**What happens with 2 conflicts (someid1, someid2):**

1. System tries to resolve `someid1`:
   - DELETE conflict row for someid1
   - COMMIT ← **REJECTED** by Dolt because someid2 conflict still exists
   - Transaction rolled back, someid1 NOT resolved

2. System tries to resolve `someid2`:
   - UPDATE document + DELETE conflict row for someid2
   - COMMIT ← **REJECTED** by Dolt because someid1 conflict still exists
   - Transaction rolled back, someid2 NOT resolved

3. Both conflicts remain unresolved, merge fails

### Required Correct Flow

```
ExecuteDoltMergeTool.cs
  └─> Collect all resolution SQL statements
        └─> For someid1: "DELETE FROM dolt_conflicts_documents WHERE ..."
        └─> For someid2: "UPDATE documents SET ...; DELETE FROM dolt_conflicts_documents WHERE ..."
  └─> Execute ALL in single transaction:
        SET @@autocommit = 0;
        DELETE FROM dolt_conflicts_documents WHERE our_doc_id = 'someid1' ...;
        UPDATE documents SET content = ... WHERE doc_id = 'someid2' ...;
        DELETE FROM dolt_conflicts_documents WHERE our_doc_id = 'someid2' ...;
        COMMIT;      ← SUCCEEDS! All conflicts resolved before commit!
        SET @@autocommit = 1;
```

---

## Why PP13-73-C2 Tests Passed But Production Failed

| Test | Why It Passed | Gap |
|------|---------------|-----|
| `PP13_73_C2_ExecuteInTransaction_WrapsSQL` | Tests `SELECT 1` and `SELECT 2` | No conflict tables involved |
| `PP13_73_C2_MergeAbort_CleansUpMergeState` | Tests abort functionality | Doesn't test resolution |
| `PP13_73_C2_IsMergeInProgress_DetectsMergeState` | Tests state detection | Doesn't test resolution |
| `PP13_73_MergeExecution_MixedResolutions_AppliesCorrectContent` | Likely auto-merged by Dolt | May not have had 2+ true conflicts |

**Critical Gap:** No test creates **exactly 2+ user-resolvable conflicts** and verifies they can ALL be resolved successfully.

---

## Assignment Objectives

### Primary Goals

1. **Implement Batch Conflict Resolution:** Create a mechanism to collect all conflict resolution SQL and execute in a single transaction
2. **Refactor Resolution Flow:** Modify the conflict resolution pipeline to defer COMMIT until all conflicts are processed
3. **Add Comprehensive Tests:** Create integration tests that specifically validate multi-conflict batch resolution
4. **Maintain Backward Compatibility:** Ensure single-conflict scenarios and auto-resolve continue working

### Success Criteria

```
1. Merge with 2+ conflicts and user-provided resolutions succeeds
2. All PP13-73 existing tests continue to pass (no regressions)
3. New batch resolution tests pass
4. Error messages clearly indicate resolution status
```

---

## Implementation Requirements

### Requirement 1: Add Batch Resolution Method to MergeConflictResolver

Create a new method that collects all SQL and executes in one transaction:

```csharp
/// <summary>
/// PP13-73-C3: Resolve multiple conflicts in a single transaction.
/// Dolt requires ALL conflicts to be resolved before COMMIT is allowed.
/// </summary>
public async Task<BatchResolutionResult> ResolveBatchAsync(
    List<(DetailedConflictInfo Conflict, ConflictResolutionRequest Resolution)> conflictResolutions)
{
    // 1. Collect all resolution SQL statements (without committing)
    // 2. Execute all in a single transaction
    // 3. Only COMMIT once all conflict rows are deleted
    // 4. Return detailed results for each conflict
}
```

### Requirement 2: Refactor DoltCli Resolution Methods

Option A: Add a method that generates SQL without executing:
```csharp
public string GenerateConflictResolutionSql(string tableName, string documentId,
    string collectionName, ConflictResolution resolution)
```

Option B: Modify `ExecuteInTransactionAsync` to accept a `commitImmediately` parameter:
```csharp
public async Task<bool> ExecuteInTransactionAsync(
    bool commitImmediately = true,  // New parameter
    params string[] sqlStatements)
```

### Requirement 3: Update ExecuteDoltMergeTool Resolution Loop

Current (broken):
```csharp
foreach (var resolution in resolutions)
{
    var resolved = await _conflictResolver.ResolveConflictAsync(conflict, resolution);
    // Each call tries to COMMIT individually
}
```

Required (batch):
```csharp
// Collect all resolutions
var batchResolutions = resolutions
    .Select(r => (detailedConflicts.First(c => c.ConflictId == r.ConflictId), r))
    .ToList();

// Resolve all in single transaction
var batchResult = await _conflictResolver.ResolveBatchAsync(batchResolutions);
```

### Requirement 4: Add Integration Tests

Create test: `PP13_73_C3_BatchResolution_TwoConflicts_BothResolved`
- Creates exactly 2 document conflicts that CANNOT be auto-merged
- Provides user resolutions for both conflicts
- Verifies BOTH are resolved successfully
- Verifies merge completes without error

Create test: `PP13_73_C3_BatchResolution_MixedStrategies_AllApplied`
- Creates 3+ conflicts
- Uses different resolution strategies (keep_ours, keep_theirs)
- Verifies each document has correct final content

Create test: `PP13_73_C3_BatchResolution_PartialFailure_ClearError`
- Tests behavior when one resolution fails (e.g., invalid document ID)
- Verifies clear error message indicating which resolution failed
- Verifies merge is properly aborted

---

## Technical Constraints

- **DO NOT** use `@@dolt_allow_commit_conflicts = 1` - this bypasses Dolt's safety checks and may cause inconsistent state elsewhere
- **MAINTAIN** all existing PP13-73-C1 and PP13-73-C2 functionality
- **PRESERVE** single-conflict resolution behavior (should work as before)
- **ENSURE** auto-resolve functionality continues to work
- **KEEP** the `ExecuteInTransactionAsync` method available for other uses

---

## Files to Modify

| File | Changes Required |
|------|------------------|
| `multidolt-mcp/Services/MergeConflictResolver.cs` | Add `ResolveBatchAsync` method |
| `multidolt-mcp/Services/IMergeConflictResolver.cs` | Add interface declaration |
| `multidolt-mcp/Services/DoltCli.cs` | Add SQL generation method OR modify transaction handling |
| `multidolt-mcp/Services/IDoltCli.cs` | Add interface declarations if needed |
| `multidolt-mcp/Tools/ExecuteDoltMergeTool.cs` | Refactor to use batch resolution |
| `multidolt-mcp/Models/MergeModels.cs` | Add `BatchResolutionResult` class if needed |
| `multidolt-mcp-testing/IntegrationTests/MergePreviewIntegrationTests.cs` | Add PP13-73-C3 tests |

---

## Validation Process

1. **Unit Test:** Verify `ResolveBatchAsync` generates correct SQL
2. **Integration Test:** Run new PP13-73-C3 tests with real Dolt operations
3. **Regression Test:** Run ALL PP13-73 tests to ensure no breakage
4. **Manual Validation:** Test against the exact scenario from `260112_MergeExecutionIssue3`:
   - Clone `pieter-prespective/newDMMSTest`
   - Checkout `mergetestbranch1`
   - Execute merge from `mergetestbranch2` with resolutions:
     ```json
     {"conf_9a2d8f82864c": "keep_ours", "conf_e66ed18e46ac": "keep_theirs"}
     ```
   - Verify merge succeeds

---

## Expected Outcome

After this fix:
1. Users can successfully merge branches with multiple conflicts
2. All conflict resolutions are applied in a single atomic transaction
3. Clear error messages indicate exactly which conflicts succeeded/failed
4. The merge execution workflow is reliable and predictable

---

## Log Evidence from Failed Execution

**Conflict Detection (correct):**
```
[13:01:59.965] PP13-73-C1: GenerateConflictId input='main_someid1_ContentModification' => 'conf_9a2d8f82864c'
[13:01:59.965] PP13-73-C1: GenerateConflictId input='main_someid2_ContentModification' => 'conf_e66ed18e46ac'
```

**Resolution Attempt 1 (fails):**
```
[13:01:59.966] Applying user resolution for conflict conf_9a2d8f82864c: KeepOurs
[13:01:59.970] Executing transaction SQL:
SET @@autocommit = 0;
DELETE FROM dolt_conflicts_documents WHERE our_doc_id = 'someid1' AND our_collection_name = 'main';
COMMIT;
SET @@autocommit = 1;
[13:02:00.173] [ERRR] Transaction failed: Merge conflict detected, transaction rolled back.
```

**Resolution Attempt 2 (fails):**
```
[13:02:00.174] Applying user resolution for conflict conf_e66ed18e46ac: KeepTheirs
[13:02:00.175] Executing transaction SQL:
SET @@autocommit = 0;
UPDATE documents SET content = ... WHERE doc_id = 'someid2' ...;
DELETE FROM dolt_conflicts_documents WHERE our_doc_id = 'someid2' ...;
COMMIT;
SET @@autocommit = 1;
[13:02:00.381] [ERRR] Transaction failed: Merge conflict detected, transaction rolled back.
```

**Final Result:**
```
[13:02:00.584] Committing merge: Merge mergetestbranch2 into mergetestbranch1 with 0 conflicts resolved
[13:02:00.778] Merge commit failed - aborting merge to clean up state
```

---

## Priority

**CRITICAL** - The merge functionality is completely broken for any scenario with 2+ conflicts. Users cannot complete merges that require conflict resolution.

---

Please log all development actions to the 'chroma-feat-design-planning-mcp' database under collection 'PP13-73-C3' following the established pattern.
